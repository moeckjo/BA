#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
"""
import os
import json
import struct
import logging
import time
from time import sleep
from fastnumbers import fast_real

from dotenv import load_dotenv, find_dotenv
from pymodbus.client.sync import ModbusTcpClient
from pymodbus.exceptions import ModbusException
from pymodbus.payload import BinaryPayloadBuilder
from pymodbus.constants import Endian

from pyconnector_template.pyconector_template import SensorFlow as SFTemplate
from pyconnector_template.pyconector_template import ActuatorFlow as AFTemplate
from pyconnector_template.pyconector_template import Connector as CTemplate
from pyconnector_template.dispatch import DispatchInInterval

logger = logging.getLogger("pyconnector")


class SensorFlow(SFTemplate):
    """
    Bundles all functionality to handle sensor messages.

    This is a template for a SensorFlow class, i.e. one that holds all
    functions that are necessary to handle messages from the device(s)
    towards the message broker. The methods could also be implemented
    into the Connector class, but are seperated to support clarity.

    Overload these functions
    ------------------------
    In order to transform this class into operational code you need
    to inherit from it and overload the following methods:
     - receive_raw_msg
     - parse_raw_msg

    Connector Methods
    -----------------
    The connector must provide the following methods to allow correct
    operation of the methods in this class:
     - _update_available_datapoints

    Connector Attributes
    --------------------
    The following attributes must be set up by the connector to
    allow these methods to run correctly:

    mqtt_client : class instance.
        Initialized Mqtt client library with signature of paho mqtt.
    SEND_RAW_MESSAGE_TO_DB : string
        if SEND_RAW_MESSAGE_TO_DB == "TRUE" will send raw message
        to designated DB via MQTT.
    MQTT_TOPIC_RAW_MESSAGE_TO_DB : string
        The topic which on which the raw messages will be published.
    datapoint_map : dict of dict.
        Mapping from datapoint key to topic. Is generated by the AdminUI.
        Looks e.e. like this:
            datapoint_map = {
                "sensor": {
                    "Channel__P__value__0": "example-connector/msgs/0001",
                    "Channel__P__unit__0": "example-connector/msgs/0002",
                },
                "actuator": {
                    "example-connector/msgs/0003": "Channel__P__setpoint__0",
                }
            }
        Note thereby that the keys "sensor" and "actuator"" must alaways be
        present, even if the child dicts are empty.
    """

    def receive_raw_msg(self, raw_data=None):
        """
        Receive raw data from Modbus maser device using. ModbusTCP.

        Poll the Modbus master device for the data specified in MODBUS_CONFIG.

        Parameters
        ----------
        raw_data : TYPE, optional
            Not used, here as we poll for data. Kept for consistency.

        Returns
        -------
        msg : dict
            The message object containing the raw unprocessed data.
            Should be formated like this:
                msg = {
                    "payload": {
                        "raw_message": <the raw data>
                    }
                }
            E.g.
                msg = {
                    "payload": {
                        "raw_message": "device_1:{sensor_1:2.12,sensor_2:3.12}"
                    }
                }
        """
        if not hasattr(self, "modbus_connection"):
            # Establish connection to modbus master device.
            logger.debug(
                "Connecting to Modbus master %s:%s",
                *(self.modbus_master_ip, self.modbus_master_port)
            )
            self.modbus_connection = ModbusTcpClient(
                host=self.modbus_master_ip,
                port=self.modbus_master_port
            )
            if not self.modbus_connection.connect():
                raise RuntimeError("Could not connect to Modbus master.")

        # Read all data requested in configuration.
        raw_message = {k: {} for k in self.modbus_read_method_names}
        for read_method_name in self.modbus_read_method_names:
            read_method = getattr(self.modbus_connection, read_method_name)
            requested_ranges = self.modbus_config[read_method_name]
            # requested_range is an entry like:
            # {
            #     "address": 19000,
            #     "count": 20,
            #     "unit": 1,
            #     "datatypes": ">ffffffffff",
            # },
            for i, requested_range in enumerate(requested_ranges):
                logger.debug(
                    "Using method %s to request data from address %s with "
                    "count %s from unit %s.",
                    *(
                        read_method_name,
                        requested_range["address"],
                        requested_range["count"],
                        requested_range["unit"],
                    )
                )
                retry = 0
                while True:
                    response = read_method(
                        address=requested_range["address"],
                        count=requested_range["count"],
                        unit=requested_range["unit"],
                    )
                    if isinstance(response, BaseException) or response.isError():
                        # This track here is if the read failed. Then we wait
                        # a bit and retry a few times before we finally fail.
                        # If we retried to often we raise the execption and
                        # exit.
                        logger.info(
                            "Reading from modbus device failed with function "
                            " %s for address %s. Retrying in %s seconds. "
                            "Error was: %s",
                            *(
                                read_method_name,
                                requested_range["address"],
                                self.retry_wait,
                                str(response),
                            )
                        )
                        retry += 1
                        if retry >= self.max_retries:
                            raise RuntimeError(
                                "Max number of retries exceeded.")
                        sleep(self.retry_wait)
                        continue
                    # Pack the registers/coils into the raw message.
                    elif "_registers" in read_method_name:
                        raw_message[read_method_name][i] = response.registers
                    else:
                        raw_message[read_method_name][i] = response.bits
                    break
                # Maybe wait a bit before next request.
                sleep(self.poll_break)

        if self.disconnect_between_polls:
            logger.debug("Disconnecting from Modbus Master.")
            self.modbus_connection.close()
            # This is required so we create a new connection next poll.
            delattr(self, "modbus_connection")

        msg = {
            "payload": {
                "raw_message": raw_message
            }
        }
        return msg

    def parse_raw_msg(self, raw_msg):
        """
        Functionality to receive a raw message from device.

        Poll the device/gateway for data and transforms this raw data
        into the format epxected by run_sensor_flow. If the device/gateway
        uses some protocol that pushes data, the raw data should be passed
        as the raw_data argument to the function.

        Be aware: All keys in the output message should be strings. All values
        should be converted be strings, too.

        Parameters
        ----------
        raw_msg : dict.
            Raw msg with data from device/gateway. Should be formated like:
                msg = {
                    "payload": {
                        "raw_message": <the raw data>,
                        "timestamp": <milliseconds since epoch>
                    }
                }

        Returns
        -------
        msg : dict
            The message object containing the parsed data as python dicts from
            dicts strucuture.
            Should be formated like this:
                msg = {
                    "payload": {
                        "parsed_message": <the parsed data as object>,
                        "timestamp": <milliseconds since epoch>
                    }
                }
            E.g:
                msg = {
                    "payload": {
                        "parsed_message": {
                            "device_1": {
                                "sensor_1": "2.12",
                                "sensor_2": "3.12"
                            }
                        },
                        "timestamp": 1573680749000
                    }
                }
        """
        raw_message = raw_msg["payload"]["raw_message"]
        parsed_message = {}
        for read_method_name in raw_message:
            parsed_message[read_method_name] = {}
            modbus_config_for_method = self.modbus_config[read_method_name]
            mbas_for_method = self.modbus_addresses[read_method_name]
            for i in raw_message[read_method_name]:
                # Load modbus addresses as strings as other stuff is loaded
                # from JSON and expects strings too.
                mbas = [str(m) for m in mbas_for_method[i]]

                if "_registers" in read_method_name:
                    registers = raw_message[read_method_name][i]
                    datatypes = modbus_config_for_method[i]["datatypes"]

                    # Now we going to to encode the registers (which are
                    # currently represented as 16bit int values) to bytes so
                    # we can decode the data back with the correct datatype.
                    # This approach is taken from the pymodbus code, which
                    # does the same but doesn't allow to decode all of the
                    # values at once.
                    values_b = b''.join(struct.pack('!H', x)
                                        for x in registers)
                    try:
                        values = struct.unpack(datatypes, values_b)
                    except struct.error:
                        logger.error(
                            "Unpacking binary data with struct failed. "
                            "The Modbus request returned %s registers, aka "
                            "%s bytes. However, you may have configured "
                            "datatypes in MODBUS_CONFIG corresponding to "
                            "a different number of bytes, see struct.error "
                            "below.",
                            *(len(registers), len(registers) * 2)
                        )
                        logger.error(f'Datatype configured in MODBUS CONFIG: {datatypes}')
                        logger.error(f'Bitstring: {values_b}')
                        raise

                else:
                    values = []
                    for value in raw_message[read_method_name][i]:
                        if value:
                            values.append("1")
                        else:
                            values.append("0")

                # Store each value under it's Modbus address.
                # This may overwrite values if overlapping address
                # ranges have been specified by the user.
                # Also apply scaling factors while we are here, but only
                # to registers. Scaling bits doesn't make sense, even if the
                # user would request it.
                sfs = {}
                if (
                        "scaling_factors" in modbus_config_for_method[i] and
                        "_registers" in read_method_name
                ):
                    sfs = modbus_config_for_method[i]["scaling_factors"]

                # check for special cases (e.g. map certain value of "cable_state" to "connected" states)
                value_maps = {}
                if "value_maps" in modbus_config_for_method[i]:
                    value_maps = modbus_config_for_method[i]["value_maps"]

                for mba, value in zip(mbas, values):

                    if mba in sfs:
                        try:
                            scaled_value = float(value) * sfs[mba]
                            value = str(scaled_value)
                        except ValueError:
                            pass

                    if mba in value_maps:
                        map = value_maps[mba]
                        try:
                            mapped_value = map[str(value)]
                            value = str(mapped_value)
                        except KeyError:
                            logger.error(f'No mapping for address={mba}, value={value}. Defined maps: {value_maps}')
                            pass

                    # All values are handled as strings in BEMCom.
                    parsed_message[read_method_name][mba] = str(value)

        msg = {
            "payload": {
                "parsed_message": parsed_message,
                "timestamp": raw_msg["payload"]["timestamp"],
            }
        }
        return msg


class ActuatorFlow(AFTemplate):
    """
    Bundles all functionality to handle actuator messages.

    This is a template for a ActuatorFlow class, i.e. one that holds all
    functions that are necessary to handle messages from the message
    broker towards the devices/gateway. The methods could also be implemented
    into the Connector class, but are seperated to support clarity.

    Overload these functions
    ------------------------
    In order to transform this class into operational code you need
    to inherit from it and overload the following methods:
     - send_command

    Connector Attributes
    --------------------
    The following attributes must be set up by the connector to
    allow these methods to run correctly:

    datapoint_map : dict of dict.
        Mapping from datapoint key to topic. Is generated by the AdminUI.
        Looks e.e. like this:
            datapoint_map = {
                "sensor": {
                    "Channel__P__value__0": "example-connector/msgs/0001",
                    "Channel__P__unit__0": "example-connector/msgs/0002",
                },
                "actuator": {
                    "example-connector/msgs/0003": "Channel__P__setpoint__0",
                }
            }
        Note thereby that the keys "sensor" and "actuator"" must alaways be
        present, even if the child dicts are empty.
    """



    def send_command(self, datapoint_key, datapoint_value):
        """
        Send message to target device, via gateway if applicable.

        TODO: Extend for writing stuff.
              FC5:  write_coil
              FC6:  write register
              FC15: write_coils
              FC16: write_registers

        Parameters
        ----------
        datapoint_key : string.
            The internal key that is used by device/gateway to identify
            the datapoint.
        value : string.
            The value that should be sent to the datapoint.
        """
        enable_device = False
        disable_device = False

        char_register_size = {
            "c": 1,
            "b": 1,
            "B": 1,
            "?": 1,
            "h": 1,
            "H": 1,
            "i": 2,
            "I": 2,
            "l": 2,
            "L": 2,
            "q": 4,
            "Q": 4,
            "e": 1,
            "f": 2,
            "d": 4,
        }
        # Examples: datapoint_key = "write_coil__10"
        if not hasattr(self, "modbus_connection"):
            # Establish connection to modbus master device.
            logger.debug(
                "Connecting to Modbus master %s:%s",
                *(self.modbus_master_ip, self.modbus_master_port)
            )
            self.modbus_connection = ModbusTcpClient(
                host=self.modbus_master_ip, port=self.modbus_master_port
            )
            if not self.modbus_connection.connect():
                raise RuntimeError("Could not connect to Modbus master.")

        mdb_datatype = ""
        mdb_method = datapoint_key.split("__")[0]
        mdb_reg = int(datapoint_key.split("__")[1])
        mdb_unit = int(datapoint_key.split("__")[2])
        if ("register" in mdb_method):
            mdb_datatype = datapoint_key.split("__")[3]
        # Apply scaling_factor if provided.
        # Parse datatype for resgisters and pack value as binary.
        # Parse coil values ("0" and "1") as Bools (True/False)

        if ('write_register__5004__1__>H' in datapoint_key):
            # validate and convert the received values --> power to charging current
            target_power = int(datapoint_value)

            if target_power == 0:
                logger.info('Target power = 0 –> disable charging station.')
                # self.send_command(datapoint_key='write_register__5014__1__>H',
                #                   datapoint_value=str(0))
                # Charging current = 0
                datapoint_value = str(0)
                disable_device = True

            else:
                # convert power to current & send current value to device
                # I = P / (230V*num_phases)
                scaling_factor = 1000

                target_current = round(target_power/(self.voltage * self.num_phases_used) * scaling_factor)
                logger.debug(f'Target power={target_power} W -> Target current per phase '
                             f'({self.num_phases_used} phases): {target_current} mA')

                # Check if the target current value is within the supported range
                if not(self.min_current <= target_current <= self.max_current):
                    logger.warning(f'Target power value ({target_power} W) is outside the supported range. '
                                 f'Supported range: '
                                   f'{(self.min_current * self.voltage * self.num_phases_used)/scaling_factor:.0f} - '
                                   f'{(self.max_current * self.voltage * self.num_phases_used)/scaling_factor:.0f} W '
                                   f'({self.min_current} - {self.max_current} mA)')
                    return

                datapoint_value = str(target_current)
                enable_device = True


        if ('write_register__5014__1__>H' in datapoint_key):
            # Datapoint for switching the device on or off (aka. enable or disable device)
            # validate the received values --> Enable/Disable charging station
            target_bool = int(datapoint_value)
            if not(target_bool in [0,1]):
                logger(f'Received an illegal target charging station state ({target_bool}).')
                return

        if ("coil" in mdb_method):
            values = False if int(datapoint_value) == 0 else True
        else:
            # values_b = b''.join(struct.pack(mdb_datatype, fast_real(datapoint_value)))
            builder = BinaryPayloadBuilder(byteorder=mdb_datatype[0], wordorder=Endian.Big)
            builder.reset()
            p_string = builder._pack_words(mdb_datatype[1:], fast_real(datapoint_value))
            builder._payload.append(p_string)
            values = builder.to_registers()[0]

        # Call write_method with parsed (aka. decoded)
        write_method = getattr(self.modbus_connection, mdb_method)
        try:
            response = write_method(
                address=mdb_reg,
                value=values,
                unit=mdb_unit,
            )
            logger.debug(
                "Sent %s to register %s in unit %s",
                *(values, mdb_reg, mdb_unit)
            )
            logger.debug("Received response for send_command: %s", response)
        finally:
            # Maybe wait a bit before next request.
            sleep(self.poll_break)

        if enable_device:
            logger.info('Send enable command.')
            self.send_command(datapoint_key='write_register__5014__1__>H',
                              datapoint_value=str(1))
        if disable_device:
            logger.info('Send disable command.')
            self.send_command(datapoint_key='write_register__5014__1__>H',
                              datapoint_value=str(0))


class Connector(CTemplate, SensorFlow, ActuatorFlow):
    """
    The generic logic of the connector.

    It should not be necessary to overload any of these methods nor
    to call any of those apart from __init__() and run().

    Configuration Attributes
    ------------------------
    Confiugration will be populated from environment variables on init.
    CONNECTOR_NAME : string
        The name of the connector instance as seen by the AdminUI.
    MQTT_TOPIC_LOGS : string
        The topics used by the log handler to publish log messages on.
    MQTT_TOPIC_HEARTBEAT : string
        The topics used by the connector to publish heartbeats on.
    MQTT_TOPIC_AVAILABLE_DATAPOINTS : string
        The topic on which the available datapoints will be published.
    MQTT_TOPIC_DATAPOINT_MAP : string
        The topic the connector will listen on for datapoint maps
    SEND_RAW_MESSAGE_TO_DB : string
        if SEND_RAW_MESSAGE_TO_DB == "TRUE" will send raw message
        to designated DB via MQTT. This is a string and not a bool as
        environment variables are always strings.
    MQTT_TOPIC_RAW_MESSAGE_TO_DB : string
        The topic which on which the raw messages will be published.
    DEBUG : string
        if DEBUG == "TRUE" will log debug message to, elso loglevel is info.
    MODBUS_MASTER_IP : string
        The ip adress or DNS name of the Modbus master device which we want
        to connect to.
    MODBUS_MASTER_PORT : string (as env variables are always strings)
        The port on which  the master device awaits Modbus communication.

    Computed Attributes
    -------------------
    These attriubutes are created by init and are then dynamically used
    by the Connector.
    mqtt_client : class instance.
        Initialized Mqtt client library with signature of paho mqtt.
    available_datapoints : dict of dict.
        Lists all datapoints known to the connector and is sent to the
        AdminUI. Actuator datapoints must be specified manually. Sensor
        datapoints are additionally automatically added once a value for
        a new datapoint is received. The object contains the connector
        internal key and a sample and value looks e.g. like this:
            available_datapoints = {
                "sensor": {
                    "Channel__P__value__0": 0.122,
                    "Channel__P__unit__0": "kW",
                },
                "actuator": {
                    "Channel__P__setpoint__0": 0.4,
                }
            }
    datapoint_map : dict of dict.
        Mapping from datapoint key to topic. Is generated by the AdminUI.
        Looks e.e. like this:
            datapoint_map = {
                "sensor": {
                    "Channel__P__value__0": "example-connector/msgs/0001",
                    "Channel__P__unit__0": "example-connector/msgs/0002",
                },
                "actuator": {
                    "example-connector/msgs/0003": "Channel__P__setpoint__0",
                }
            }
        Note thereby that the keys "sensor" and "actuator"" must alaways be
        present, even if the child dicts are empty.
    """

    def __init__(self, *args, **kwargs):
        """
        Init the inherited code from python_connector_template and add
        function to parse the special environment variable args to configure
        this connector.
        """
        # dotenv allows us to load env variables from .env files which is
        # convient for developing. If you set override to True tests
        # may fail as the tests assume that the existing environ variables
        # have higher priority over ones defined in the .env file.
        load_dotenv(find_dotenv('.env'), verbose=True, override=False)
        # We need to specify a dispatcher that triggers the connection with
        # the device or gateway. Here we want to poll the device with the
        # interval set in the POLL_SECONDS environment variable.
        kwargs["DeviceDispatcher"] = DispatchInInterval
        kwargs["device_dispatcher_kwargs"] = {
            "call_interval": float(os.getenv("POLL_SECONDS"))
        }

        # CTemplate.__init__(self, *args, **kwargs)
        self.CONNECTOR_NAME = os.getenv("CONNECTOR_NAME")
        logger.debug(f'My name is: {self.CONNECTOR_NAME}')

        self.modbus_master_ip = os.getenv("MODBUS_MASTER_IP")
        self.modbus_master_port = int(os.getenv("MODBUS_MASTER_PORT"))

        self.modbus_config = self.load_and_parse_modbus_config(
            path=os.getenv("MODBUS_CONFIG_PATH")
        )
        self.modbus_addresses = self.compute_addresses(
            modbus_config=self.modbus_config
        )

        # add read methods to connector
        self.modbus_read_method_names = [
            k for k in self.modbus_config if "read_" in k
        ]
        # add write methods to connector
        self.modbus_write_method_names = [
            k for k in self.modbus_config if "write_" in k
        ]

        kwargs["available_datapoints"] = {
            "sensor": {},
            "actuator": self.computeActuatorDatapoints()
        }

        kwargs["datapoint_map"] = self.load_and_parse_datapoint_map(
            path=os.getenv("DATAPOINTMAP_PATH")
        )
        logger.debug(f'My DATAPOINT_MAP: \n{kwargs["datapoint_map"]}')


        CTemplate.__init__(self, *args, **kwargs)

        self.max_retries = int(os.getenv("MODBUS_MAX_RETRIES") or 3)
        self.retry_wait = int(os.getenv("MODBUS_RETRY_WAIT_SECONDS") or 15)
        self.poll_break = float(os.getenv("MODBUS_POLL_BREAK") or 0)
        self.disconnect_between_polls = False
        if os.getenv("MODBUS_DISCONNECT_BETWEEN_POLLS") == "TRUE":
            self.disconnect_between_polls = True

        # Number of phases used for charging (needed for calculating current per phase from target power)
        self.num_phases_used = int(os.getenv('NUM_PHASES_USED', 3))
        self.voltage = int(os.getenv('VOLTAGE', 230))
        self.min_current = int(os.getenv('MIN_CURRENT', 6)) * 1000  # mA
        self.max_current = int(os.getenv('MAX_CURRENT', 63)) * 1000  # mA

    def computeActuatorDatapoints(self):
        actuator_temp = {}
        for write_method in self.modbus_write_method_names:
            for requested_range in self.modbus_config[write_method]:
                if "_coil" in write_method:
                    datapoint = write_method + "__" + \
                                str(requested_range["address"]) + \
                                "__" + str(requested_range["unit"])
                    # value = requested_range["value"] or 0
                    actuator_temp.update({datapoint: "0"})
                elif "_register" in write_method:
                    datapoint = write_method + "__" + \
                                str(requested_range["address"]) + "__" + str(requested_range["unit"]) + \
                                "__" + \
                                requested_range["datatypes"]  # TODO add scaling factor
                    # value = requested_range["value"] or 0
                    actuator_temp.update({datapoint: "0"})
        return actuator_temp

    @staticmethod
    def load_and_parse_modbus_config(path):
        """
        Parse and verify the configuration JSON string.

        This also removes unexpected components of the config.

        Arguements:
        -----------
        config_json_str : string
            The MODBUS_CONFIG JSON string as defined in the Readme.

        Returns:
        --------
        config : dict
            The parsed version of the input.
        """
        logger.info("Loading MODBUS_CONFIG.")
        with open(path, 'r') as read_file:
            config_dict = json.load(read_file)

        logger.info("Parsing MODBUS_CONFIG.")

        expected_config_keys = [
            "read_coils",
            "read_discrete_inputs",
            "read_holding_registers",
            "read_input_registers",
            "write_register",
            "write_coil"
        ]

        for config_key in list(config_dict.keys()):
            if config_key not in expected_config_keys:
                logger.warning(
                    "Found unexpected key in MODBUS_CONFIG: %s"
                    "The corresponding values are:\n%s",
                    *(config_key, json.dumps(config_dict[config_key], indent=2))
                )
                del config_dict[config_key]

        return config_dict

    @staticmethod
    def compute_addresses(modbus_config):
        """
        Compute the corresponding register and coil addresses to the address
        ranges specified by the user in MODBUS_CONFIG.

        Arguments:
        ----------
        path : str , required
            Path to the json file's location.
        """

        # These are the Modbus functions (supported by the connector)
        # that interact with registers.
        method_names = [
            "read_coils",
            "read_discrete_inputs",
            "read_holding_registers",
            "read_input_registers"
        ]

        # These is the mapping from the struct keys to the Modbus
        # register count, that is how many registers are filled with that
        # variable. See also:
        # https://docs.python.org/3/library/struct.html#format-characters
        char_register_size = {
            "c": 1,
            "b": 1,
            "B": 1,
            "?": 1,
            "h": 1,
            "H": 1,
            "i": 2,
            "I": 2,
            "l": 2,
            "L": 2,
            "q": 4,
            "Q": 4,
            "e": 1,
            "f": 2,
            "d": 4,
        }

        addresses = {}
        for method_name in method_names:
            if method_name not in modbus_config:
                continue

            addresses[method_name] = {}
            requested_ranges = modbus_config[method_name]

            if "register" in method_name:
                for i, requested_range in enumerate(requested_ranges):
                    # The first value starts at the start of the
                    # address range.
                    range_addresses = []
                    current_address = requested_range["address"]
                    for datatype_char in requested_range["datatypes"]:
                        if datatype_char not in char_register_size:
                            # Ignore chars defining endianess or padding.
                            continue

                        # Append the address this value starts and add it's
                        # length so we get the starting address of the next
                        # value.
                        range_addresses.append(current_address)
                        current_address += char_register_size[datatype_char]

                    # Finally store the addresses of this range under the
                    # index the range has in the config.
                    addresses[method_name][i] = range_addresses

            else:
                # Handling for read_discrete_inputs and read_coils methods,
                # is acutally quite simple as every bit is exactly one bit
                # long :)
                for i, requested_range in enumerate(requested_ranges):
                    start = requested_range["address"]
                    count = requested_range["count"]
                    addresses[method_name][i] = list(range(start, start + count))

        return addresses

    def load_and_parse_datapoint_map(self, path: str) -> dict:
        """
        Method imports the DATAPOINTMAP information,
        controls its structure and adds the connectors_name
        to the MQTT topics

        Parameters
        -----------
        path : str , required
            Path to the json file's location

        Returns
        -----------
        datapoint_map_dict : dict
            The DATAPOINT_MAP parsed as a directory. If there
            was an error in the structure, only an empty directory.
        """
        cn = self.CONNECTOR_NAME

        logger.info("Loading DATAPOINT_MAP")
        with open(path, 'r') as read_file:
            datapoint_map_dict = json.load(read_file)

        logger.info("Parsing DATAPOINT_MAP")

        expected_first_keys = [
            "sensor",
            "actuator"
        ]

        actual_first_keys = list(datapoint_map_dict.keys())
        actual_first_keys = [single_string.lower() for single_string in actual_first_keys]

        if set(actual_first_keys) != set(expected_first_keys):
            logger.warning(f'The datapoint map has an incorrect structure.'
                           f'Here are its top-level elements: {set(actual_first_keys)}')
            datapoint_map_dict = {}
            return datapoint_map_dict

        for curr_datapoint in datapoint_map_dict['sensor'].keys():
            curr_mqtt_ada = cn + datapoint_map_dict['sensor'][curr_datapoint]
            datapoint_map_dict['sensor'][curr_datapoint] = curr_mqtt_ada

        list_actuator_keys = list(datapoint_map_dict['actuator'].keys())
        for curr_mqtt in list_actuator_keys:
            datapoint_map_dict['actuator'][cn + curr_mqtt] = datapoint_map_dict['actuator'].pop(curr_mqtt)

        return datapoint_map_dict



if __name__ == "__main__":
    logger.info(f'modbus-tcp-connector-keba-p30 - pushed on October 31th')
    connector = Connector()
    connector.run()
